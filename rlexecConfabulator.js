var fs = require ('fs');
var u = require('./utils');

var polo = null;
var c = null;
var volumes = {};
var policies = {};
var PRICE_RESOLUTION = 1;
var rlexec_config = { // TODO: This should be generated by rlexec itself
    noof_actions: 8,
    action_lu: {
        ALU_1AV:        0,
        ALU_05AV:       1,
        ALU_025AV:      2,
        ALU_0125AV:     3,
        ALU_00625AV:    4,
        ALU_NEAR:       5,
        ALU_MID:        6,
        ALU_FAR:        7,
        ALU_MARKET:     8,
    },
    policy_dir: './rlexec_output/1536370926_1536731934/',
    full_volume: 10000000, // 100mB
    full_period: 180000,  // 180s
    volumes_file: 'volumes.json',
    policy_file: 'policy.json',
    volume_divizor: 30,    // TODO: This should not be linear (preferably recorded by rlexec per market)
    vol_rez: 8,
    time_rez: 8,
    types: {
        Buy:    0,
        Sell:   1,
    },
};

function init_volumes (rlc) {
	fs.readFile (rlc['policy_dir'] + rlc['volumes_file'], 'utf8', function (err, data) {
        if (err) {
            console.log(`Error reading volumes file ${rlc['volumes_file']}: ${err}`);
            return;
        }
        console.log(rlc['volumes_file'] + " dump: " + data);
		json = JSON.parse(data);
        for (market in Object.keys(data)) {
            volumes[market] = data[market] / rlc.volume_divizor;
        }
    });
}

function init_policies (rlc) {
    let policies = {};
    fs.readdir (rlc['policy_dir'], function (err, items) {
        if (err) {
            console.log('Error reading policy dir ' + rlc['policy_dir'] + ": " + err);
            return;
        }
        console.log("Got " + items.len + " market policies: " + JSON.stringify (items) + " policies=" + policies);
        for (let market in items) {
            console.log("1 = market = " + market);
            if (!fs.lstatSync(rlc['policy_dir'] + items[market]).isDirectory()) {
                continue;
            }
            console.log("2 = market = " + market);
            fn = rlc['policy_dir'] + items[market] + '/' + rlc['policy_file'];
            console.log("3 = market = " + market);
            fs.readFile (fn, function (err, data) {
                console.log("4 = market = " + market + " policies=" + policies);
                if (err) {
                    console.log('Error reading policy file ' + fn + ': ' + err);
                    return;
                }
                console.log(fn + " contents: " + data + ' (market=' + market + ', item=' + items[market] + ')'); 
                policies[items[market]] = JSON.parse (data);
            });
        }
    });
    return policies;
}

function action_price(market, act, action, remaining_amount) {    // Should be an exact js rendition of rlexec function. Meh.

    if (act['type'] == 'Buy') {
//    return .5 * (getSortedOB(market['ob_bids']).reverse()[0][0] + getSortedOB(market['ob_asks'])[0][0]);
        our_obkv = u.getSortedOB(market['ob_bids']).reverse();
        their_obkv = u.getSortedOB(market['ob_asks']);
    } else {
        if (act['type'] != 'Sell') {
            throw "Unknown act type " + act['type'];
        }
        assert (act['type'] == 'Sell');
        our_obkv = u.getSortedOB(market['ob_asks']);
        their_obkv = u.getSortedOB(market['ob_bids']).reverse();
    }
    our0 = our_obkv[0][0];
    their0 = their_obkv[0][0];
    if (action <= rlexec_config['action_lu']['ALU_00625AV']) {
//        no_deeper_than = u.get_mid_price (market) * 2. ** (-action); // WAT?! This should be volume, not price.
        no_deeper_than = (volumes[act['mname']] / rlexec_config['volume_divizor'])  * 2. ** (-action);
        price = get_depth_price (no_deeper_than, our_obkv);
        if (act['type'] == 'Buy') {
            if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                return price;
            } else {
                return price + PRICE_RESOLUTION;
            }
        } else {
            if (price - PRICE_RESOLUTION <= their0) {
                return price;
            } else {
                return price - PRICE_RESOLUTION;
            }
        }

/*
        console.log ('no_deeper_than = ' + str(no_deeper_than) + 'altsat');
        v = 0;
        i = 0;
        for ((price, volume) in our_obkv) {
            i++;
            console.log('price = ' + str(price) + 'bsat => v + volume = ' + str(v) + 'altsat + ' + str(volume) + 'altsat');
            if (v + volume > no_deeper_than) {
                if (act['type'] == 'Buy') {
                    if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                        return price;
                    } else {
                        return price + PRICE_RESOLUTION;
                    }
                } else {
                    if (price - PRICE_RESOLUTION <= their0) {
                        return price;
                    } else {
                        return price - PRICE_RESOLUTION;
                    }
                }
            } else {
                v += volume;
            }
        }
        throw "OB depleted";
*/
    } else if (action == rlexec_config['action_lu']['ALU_NEAR']) {
        if (act['type'] == 'Buy') {
            if (our0 + PRICE_RESOLUTION >= their0) {
                return our0;
            } else {
                return our0 + PRICE_RESOLUTION;
            }
        } else {
            if (our0 - PRICE_RESOLUTION <= their0) {
                return our0;
            } else {
                return our0 - PRICE_RESOLUTION;
            }
        }
    } else if (action == rlexec_config['action_lu']['ALU_MID']) {
        if (act['type'] == 'Buy') {
            if (Math.floor((our0 + their0) / 2) >= their0) {
                return their0 - PRICE_RESOLUTION;
            } else {
                return Math.floor((our0 + their0) / 2);
            }
        } else {
            if (Math.floor((our0 + their0) / 2) <= their0) {
                return their0 + PRICE_RESOLUTION;
            } else {
                return Math.floor((our0 + their0) / 2);
            }
        }
    } else if (action == rlexec_config['action_lu']['ALU_FAR']) {
        if (act['type'] == 'Buy') {
            return their0 - PRICE_RESOLUTION;
        } else {
            return their0 + PRICE_RESOLUTION;
        }
    } else if (action == rlexec_config['action_lu']['ALU_MARKET']) {
        no_deeper_than = remaining_amount * 1.5; // to increase chance of being filled.
        return u.get_depth_price (no_deeper_than, their_obkv);
    } else {
        throw "invalid action " + action;
    }
}

module.exports = {

    init: function (config, _polo) {
        polo = _polo;
        c = config;
        init_volumes (rlexec_config);
        policies = init_policies (rlexec_config);
    },

//  act={"start":1528285827585,"timeout":60,"prev_balance":0,"current_balance":0,"total_amount":74.86000318514343,"type":"Buy","my_orders":{},"amount_changed":0,"trades":[],"triggerRunning":true,"done":false}

    calc_new_orders: function (mname, act, market, remaining_amount) {

        vol_frac = Math.floor (100000000 * rlexec_config.vol_rez * remaining_amount /* * u.midprice (market) */ / rlexec_config.full_volume)
        console.log('mname = ' + mname + ' market = ' + market + ' vol_frac = int (100000000 * ' + rlexec_config.vol_rez + ' * ' + remaining_amount /* + ' * ' + u.midprice (market) */ + ' / ' + rlexec_config.full_volume + ') = ' + vol_frac + "(" + (100000000 * rlexec_config.vol_rez * remaining_amount /* * u.midprice (market) */ / rlexec_config.full_volume) + ")");
        if (vol_frac < 0 || vol_frac > rlexec_config.vol_rez - 1) {
            console.log('Crashing - vol_rez = ' + rlexec_config.vol_rez);
            throw new RangeError('Crashing - vol_rez = ' + rlexec_config.vol_rez);
        }

//        time_frac = Math.floor (rlexec_config.time_rez * (1. - (Date.now() - act['start']) / act['timeout']))
        time_frac = Math.floor (rlexec_config.time_rez * ((Date.now() - act['start']) / act['timeout']))
        console.log('time_frac = int (' + rlexec_config.time_rez + ' * (' + Date.now() + ' - ' + act['start'] + ') / ' + act['timeout'] + ') = ' + time_frac);
        if (time_frac < 0) {
            console.log('action = ALU_MARKET');
            action = rlexec_config['action_lu']['ALU_MARKET'];
        } else if (time_frac > rlexec_config.time_rez - 1) {
            console.log('Crashing - time_rez = ' + rlexec_config.time_rez);
            throw new RangeError('Crashing - time_rez = ' + rlexec_config.time_rez);
        } 
        else {
            action = policies[mname][rlexec_config['types'][act['type']]][time_frac][vol_frac];
            console.log('action = ' + action);
            if (action < 0 || action > rlexec_config['noof_actions']) {
                console.log('Crashing - action = ' + action);
                throw new RangeError('Crashing - action = ' + action);
            }
        }

        price = action_price(market, act, action, remaining_amount);

        return  { price: {  'mname':    mname,
                            'rate':     price,
                            'type':     act['type'],
                            'amount':   remaining_amount, }, };
    }
/*    calc_new_orders: function (mname, act, market, remaining_amount) {
*/
        /*
        if (act['type'] != 'Buy') {
            console.log('Cannot confabulate sell orders.');
            return;
        }
        */
/*
        now = Date.now();

        // Trivial stupid ass thing
        if (now - act['start'] > act['timeout'] * 1000) {
            if (act['type'] == 'Buy') {
                return marketBuy(mname, remaining_amount, market);
            } else if (act['type'] == 'Sell') {
                return marketSell(mname, remaining_amount, market);
            } else {
                console.log("Unknown order type: " + act['type']);
            }
        }

//        dumpOB(market['ob_bids']);

        stupidReturnValue = {};
        
        if (act['type'] == 'Buy') {
            price = getSortedOB(market['ob_bids']).reverse()[0][0] + (c['PAPER_TRADE'] ? 0 : c['PRICE_RESOLUTION']);
            console.log("New order price: " + price + " (" + (act['start'] + act['timeout'] * 1000 - now) + "ms remaining)");

            stupidReturnValue[price] = {    'mname': mname,
                                            'rate': price,
                                            'type': 'Buy',
                                            'amount': remaining_amount, };
        } else if (act['type'] == 'Sell') {
            price = getSortedOB(market['ob_asks'])[0][0] - (c['PAPER_TRADE'] ? 0 : c['PRICE_RESOLUTION']);
            console.log("New order price: " + price + " (" + (act['start'] + act['timeout'] * 1000 - now) + "ms remaining)");

            stupidReturnValue[price] = {    'mname': mname,
                                            'rate': price,
                                            'type': 'Sell',
                                            'amount': remaining_amount, };
        } else {
            console.log("Unknown order type: " + act['type']);
        }

        return stupidReturnValue;
/*        return { price: {'mname': mname,
                         'rate': price,
                         'type': 'Buy',
                         'amount': remaining_amount
        }};*/
/*    },

};

function marketBuy(mname, remaining_amount, market) {

    console.log("\n*** MARKET BUY ***\n");
    price = 2 * getSortedOB(market['ob_bids']).reverse()[0][0];

    stupidReturnValue = {};
    stupidReturnValue[price] = {    'mname': mname,
                                    'rate': price,
                                    'type': 'Buy',
                                    'amount': remaining_amount, };
    return stupidReturnValue;
/*    return { price: {'mname': mname,  // How?! How can you think price is a literal?!
                     'rate': price,
                     'type': 'Buy',
                     'amount': remaining_amount,
    }};*/
/*
}

function marketSell(mname, remaining_amount, market) {

    console.log("\n*** MARKET SELL ***\n");
    price = 0.5 * getSortedOB(market['ob_asks'])[0][0];

    stupidReturnValue = {};
    stupidReturnValue[price] = {    'mname': mname,
                                    'rate': price,
                                    'type': 'Sell',
                                    'amount': remaining_amount, };
    return stupidReturnValue;
/*    return { price: {'mname': mname,  // How?! How can you think price is a literal?!
                     'rate': price,
                     'type': 'Buy',
                     'amount': remaining_amount,
    }};*/

}


/*    def action_price (self, action, e, mode):   # This is adapted from gym env, and should probably be put in a separate place.
                                                # Also, this is markedly different from the paper method of getting prices, which I don't understand.
        if action <= ALU_00625AV:
#            no_deeper_than = self.average_volume * 2. ** (-action)
            no_deeper_than = e.average_volume * 2. ** (-action)
            logging.debug ('no_deeper_than = ' + str(no_deeper_than) + 'altsat')
            v = 0
            volume = 0
            i = 0
            if mode == MLU_BUY:
                our_obkv = e.bids_ob.__reversed__()
                our_obd = e.bids_ob
            else:
                our_obkv = e.asks_ob.keys()
                our_obd = e.asks_ob
            for price in our_obkv:
                i = i + 1
                volume = our_obd[price]
                logging.debug('price = ' +str(price) + 'bsat => v + volume = ' + str(v) + 'altsat + ' + str(volume) + 'altsat')
                if v + volume > no_deeper_than:
                    if mode == MLU_BUY:
                        if price + PRICE_RESOLUTION >= e.asks_ob.keys()[0]: # Don't overstep into their ob too soon
                            return price
                        else:
                            return price + PRICE_RESOLUTION
                    else:
                        if price - PRICE_RESOLUTION <= e.bids_ob.keys()[-1]:
                            return price
                        else:
                            return price - PRICE_RESOLUTION
                else:
                    v = v + volume
            logging.error('length of ob: ' + str(len(our_obd.keys())) + ' after ' + str(i) + ' iterations')
#            assert False, 'v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action)
            logging.error('OB depleted: accum. v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action))
            logging.error('Our ob dump: ' + str(our_obd))
            assert False, 'market='+self.market+'length of ob: ' + str(len(our_obd.keys())) + ' after ' + str(i) + ' iterations'+'OB depleted: accum. v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action)+'Our ob dump: ' + str(our_obd)
        if mode == MLU_BUY:
            our0 = e.bids_ob.keys()[-1]
            their0 = e.asks_ob.keys()[0]
        else:
            our0 = e.asks_ob.keys()[0]
            their0 = e.bids_ob.keys()[-1]
        logging.debug('our0 = ' + str(our0) + 'bsat their0 = ' + str(their0) + 'bsat') */
/*        if action == ALU_NEAR:
            if mode == MLU_BUY:
                if our0 + PRICE_RESOLUTION >= their0:
                    return our0
                else:
                    return our0 + PRICE_RESOLUTION
            else:
                if our0 - PRICE_RESOLUTION <= their0:
                    return our0
                else:
                    return our0 - PRICE_RESOLUTION
        if action == ALU_MID:
            if mode == MLU_BUY:
                if (our0 + their0) // 2 >= their0:
                    return their0 - PRICE_RESOLUTION
                else:
                    return (our0 + their0) // 2
            else:
                if (our0 + their0) // 2 <= their0:
                    return their0 + PRICE_RESOLUTION
                else:
                    return (our0 + their0) // 2
        if action == ALU_FAR:
            if mode == MLU_BUY:
                return their0 - PRICE_RESOLUTION
            else:
                return their0 + PRICE_RESOLUTION*/
