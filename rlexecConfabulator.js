var fs = require ('fs');
var u = require('./utils');

var polo = null;
var c = null;
var volumes = {};
var policies = {};
var PRICE_RESOLUTION = 1./100000000;
var rlexec_config = { // TODO: This should be generated by rlexec itself
	noof_actions:	16,
    action_lu: {
	    ALU_1AV:		0,
	    ALU_05AV:       1,
	    ALU_025AV:      2,
	    ALU_0125AV:     3,
	    ALU_00625AV:    4,
	    ALU_003125AV:   5,
	    ALU_00150625AV: 6,
	    ALU_NEAR:       7,
	    ALU_MID_NEAR:   8,
	    ALU_MID:        9,
	    ALU_MID_FAR:    10,
	    ALU_FAR:        11,
	    ALU_BR_0125:    12,
	    ALU_BR_025:     13,
	    ALU_BR_05:      14,
	    ALU_BR_075:     15,
		ALU_MARKET:		16,
/*    noof_actions: 8,
    action_lu: {
        ALU_1AV:        0,
        ALU_05AV:       1,
        ALU_025AV:      2,
        ALU_0125AV:     3,
        ALU_00625AV:    4,
        ALU_NEAR:       5,
        ALU_MID:        6,
        ALU_FAR:        7,
        ALU_MARKET:     8,*/
    },
//    policy_dir: './rlexec_output/1536370926_1536731934/',
//    policy_dir: './rlexec_output/1538198224_1538778880/',
    policy_dir: './rlexec_output/1544853989/',
    full_volume: 10000000, // 100mB
//    full_period: 180000,  // 180s
    full_period: 360000,  // 360s
    volumes_file: 'volumes.json',
    policy_file: 'policy.json',
//    volume_divizor: 30,    // TODO: This should not be linear (preferably recorded by rlexec per market)
    volume_divizor: 5,
    vol_rez: 8,
    time_rez: 8,
    types: {
        Buy:    0,
        Sell:   1,
    },
};

function init_volumes (rlc) {
	fs.readFile (rlc['policy_dir'] + rlc['volumes_file'], 'utf8', function (err, data) {
        if (err) {
            console.log(`Error reading volumes file ${rlc['volumes_file']}: ${err}`);
            return;
        }
//        console.log(rlc['volumes_file'] + " dump: " + data);
		json = JSON.parse(data);
        for (market in Object.keys(json)) {
            mname = Object.keys(json)[market];
            volumes[mname] = json[mname] / rlc.volume_divizor;  // bsats per period (360s)
        }
    });
}

function init_policies (rlc) {
    let policies = {};
    fs.readdir (rlc['policy_dir'], function (err, items) {
        if (err) {
            console.log('Error reading policy dir ' + rlc['policy_dir'] + ": " + err);
            return;
        }
//        console.log("Got " + items.len + " market policies: " + JSON.stringify (items) + " policies=" + policies);
        for (let market in items) {
//            console.log("1 = market = " + market);
            if (!fs.lstatSync(rlc['policy_dir'] + items[market]).isDirectory()) {
                continue;
            }
//            console.log("2 = market = " + market);
            fn = rlc['policy_dir'] + items[market] + '/' + rlc['policy_file'];
//            console.log("3 = market = " + market);
            fs.readFile (fn, function (err, data) {
//                console.log("4 = market = " + market + " policies=" + policies);
                if (err) {
                    console.log('Error reading policy file ' + fn + ': ' + err);
                    return;
                }
//                console.log(fn + " contents: " + data + ' (market=' + market + ', item=' + items[market] + ')'); 
                policies[items[market]] = JSON.parse (data);
            });
        }
    });
    return policies;
}

function action_price (market, act, action, remaining_amount) {

	if (rlexec_config['noof_actions'] == 8)
		return action_price_8a (market, act, action, remaining_amount);
	else if (rlexec_config['noof_actions'] == 16)
		return action_price_16a (market, act, action, remaining_amount);
	throw "Unknown number of actions" + rlexec_config['noof_actions'];
}

function action_price_8a (market, act, action, remaining_amount) {    // Should be an exact js rendition of rlexec function. Meh.
                                                                  // MAJOR BUG - we our running away from our on shadow. Fixed?

    if (act['type'] == 'Buy') {
//    return .5 * (getSortedOB(market['ob_bids']).reverse()[0][0] + getSortedOB(market['ob_asks'])[0][0]);
        our_obkv = u.getSortedOB(u.remove_self_from_ob(market['ob_bids'], act)).reverse();
        their_obkv = u.getSortedOB(market['ob_asks']);
    } else {
        if (act['type'] != 'Sell') {
            console.log("Crashing - Unknown act type " + act['type']);
            process.exit(1);
            throw "Unknown act type " + act['type'];
        }
        our_obkv = u.getSortedOB(u.remove_self_from_ob(market['ob_asks'], act));
        their_obkv = u.getSortedOB(market['ob_bids']).reverse();
    }
    our0 = parseFloat(our_obkv[0][0]);
    their0 = parseFloat(their_obkv[0][0]);
    if (action <= rlexec_config['action_lu']['ALU_00625AV']) {
//        no_deeper_than = u.get_mid_price (market) * 2. ** (-action); // WAT?! This should be volume, not price.
//        no_deeper_than = (volumes[act['mname']] / rlexec_config['volume_divizor'])  * 2. ** (-action);
        no_deeper_than = volumes[act['mname']] * 2. ** (-action);
//        console.log("volumes[" + act['mname'] + "] = " + volumes[act['mname']] + " volumes = " + JSON.stringify(volumes));
//        console.log("no_deeper_than = (" + volumes[act['mname']] + " / " + rlexec_config['volume_divizor'] + ") * " + 2. ** (-action) + " = " + no_deeper_than);
        console.log("no_deeper_than = " + volumes[act['mname']] + " * " + 2. ** (-action) + " = " + no_deeper_than + 'bsat');
        no_deeper_than /= 100000000 * 0.5 * (parseFloat(our0) + parseFloat(their0));
        console.log('no_deeper_than /= 100000000 * ' + (0.5 * (parseFloat(our0) + parseFloat(their0))) + ' = ' + no_deeper_than + 'alt');
        price = parseFloat(u.get_depth_price (no_deeper_than, our_obkv));
        if (act['type'] == 'Buy') {
            if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                return price;
            } else {
                return price + PRICE_RESOLUTION;
            }
        } else {
            if (price - PRICE_RESOLUTION <= their0) {
                return price;
            } else {
                return price - PRICE_RESOLUTION;
            }
        }

/*
        console.log ('no_deeper_than = ' + str(no_deeper_than) + 'altsat');
        v = 0;
        i = 0;
        for ((price, volume) in our_obkv) {
            i++;
            console.log('price = ' + str(price) + 'bsat => v + volume = ' + str(v) + 'altsat + ' + str(volume) + 'altsat');
            if (v + volume > no_deeper_than) {
                if (act['type'] == 'Buy') {
                    if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                        return price;
                    } else {
                        return price + PRICE_RESOLUTION;
                    }
                } else {
                    if (price - PRICE_RESOLUTION <= their0) {
                        return price;
                    } else {
                        return price - PRICE_RESOLUTION;
                    }
                }
            } else {
                v += volume;
            }
        }
        throw "OB depleted";
*/
    } else if (action == rlexec_config['action_lu']['ALU_NEAR']) {
        if (act['type'] == 'Buy') {
            if (our0 + PRICE_RESOLUTION >= their0) {
                console.log('ALU_NEAR Buy: our0 = ' + our0);
                return our0;
            } else {
                console.log('ALU_NEAR Buy: price = ' + our0 + ' + ' + PRICE_RESOLUTION);
                return our0 + PRICE_RESOLUTION;
            }
        } else {
            if (our0 - PRICE_RESOLUTION <= their0) {
                console.log('ALU_NEAR Sell: our0 = ' + our0);
                return our0;
            } else {
                console.log('ALU_NEAR Sell: price = ' + our0 + ' - ' + PRICE_RESOLUTION);
                return our0 - PRICE_RESOLUTION;
            }
        }
    } else if (action == rlexec_config['action_lu']['ALU_MID']) {
        if (act['type'] == 'Buy') {
            if (Math.floor((our0 + their0) / 2) >= their0) {
                console.log('ALU_MID Buy: price = their0 - rez = ' + their0 - PRICE_RESOLUTION);
                return their0 - PRICE_RESOLUTION;
            } else {
                console.log('ALU_MID Buy: price = (our0 + their0) / 2 = ' + ((our0 + their0) / 2));
                return ((our0 + their0) / 2);
            }
        } else {
            if (Math.floor((our0 + their0) / 2) <= their0) {
                console.log('ALU_MID Sell: price = their0 + rez = ' + (their0 + PRICE_RESOLUTION));
                return their0 + PRICE_RESOLUTION;
            } else {
                console.log('ALU_MID Sell: price = (our0 + their0) / 2 = ' + ((our0 + their0) / 2));
                return ((our0 + their0) / 2);
            }
        }
    } else if (action == rlexec_config['action_lu']['ALU_FAR']) {
        if (act['type'] == 'Buy') {
            console.log('ALU_FAR Buy: price = their0 - rez = ' + their0 - PRICE_RESOLUTION);
            return their0 - PRICE_RESOLUTION;
        } else {
            console.log('ALU_FAR Sell: price = their0 + rez = ' + their0 + PRICE_RESOLUTION);
            return their0 + PRICE_RESOLUTION;
        }
    } else if (action == rlexec_config['action_lu']['ALU_MARKET']) {
        act['market_order'] = true;
        no_deeper_than = remaining_amount * 1.5; // to increase chance of being filled.
        if (act['type'] == 'Buy') {
            return parseFloat(u.get_depth_price (no_deeper_than, their_obkv)) + PRICE_RESOLUTION;
        } else {
            return parseFloat(u.get_depth_price (no_deeper_than, their_obkv)) - PRICE_RESOLUTION;
        }
    } else {
        logging.error("Crashing - invalid action " + action);
        process.exit(1);
        throw "invalid action " + action;
    }
}

function action_price_16a(market, act, action, remaining_amount) {    // Should be an exact js rendition of rlexec function. Meh.
                                                                  	  // MAJOR BUG - we our running away from our on shadow. Fixed?

    if (act['type'] == 'Buy') {
//    return .5 * (getSortedOB(market['ob_bids']).reverse()[0][0] + getSortedOB(market['ob_asks'])[0][0]);
        our_obkv = u.getSortedOB(u.remove_self_from_ob(market['ob_bids'], act)).reverse();
        their_obkv = u.getSortedOB(market['ob_asks']);
    } else {
        if (act['type'] != 'Sell') {
            console.log("Crashing - Unknown act type " + act['type']);
            process.exit(1);
            throw "Unknown act type " + act['type'];
        }
        our_obkv = u.getSortedOB(u.remove_self_from_ob(market['ob_asks'], act));
        their_obkv = u.getSortedOB(market['ob_bids']).reverse();
    }
    our0 = parseFloat(our_obkv[0][0]);
    their0 = parseFloat(their_obkv[0][0]);
    if (action <= rlexec_config['action_lu']['ALU_00150625AV']) {
        no_deeper_than = volumes[act['mname']] * 2. ** (-action);
        console.log("no_deeper_than = " + volumes[act['mname']] + " * " + 2. ** (-action) + " = " + no_deeper_than + 'bsat');
        no_deeper_than /= 100000000 * 0.5 * (parseFloat(our0) + parseFloat(their0));
        console.log('no_deeper_than /= 100000000 * ' + (0.5 * (parseFloat(our0) + parseFloat(their0))) + ' = ' + no_deeper_than + 'alt');
        price = parseFloat(u.get_depth_price (no_deeper_than, our_obkv));
        if (act['type'] == 'Buy') {
            if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                return price;
            } else {
                return price + PRICE_RESOLUTION;
            }
        } else {
            if (price - PRICE_RESOLUTION <= their0) {
                return price;
            } else {
                return price - PRICE_RESOLUTION;
            }
        }
    } else if (action == rlexec_config['action_lu']['ALU_NEAR']) {
        if (act['type'] == 'Buy') {
            if (our0 + PRICE_RESOLUTION >= their0) {
                console.log('ALU_NEAR Buy: our0 = ' + our0);
                return our0;
            } else {
                console.log('ALU_NEAR Buy: price = ' + our0 + ' + ' + PRICE_RESOLUTION);
                return our0 + PRICE_RESOLUTION;
            }
        } else {
            if (our0 - PRICE_RESOLUTION <= their0) {
                console.log('ALU_NEAR Sell: our0 = ' + our0);
                return our0;
            } else {
                console.log('ALU_NEAR Sell: price = ' + our0 + ' - ' + PRICE_RESOLUTION);
                return our0 - PRICE_RESOLUTION;
            }
        }
/*       if action >= ALU_MID_NEAR and action <= ALU_MID_FAR:
            if action == ALU_MID_NEAR:
                wanted_price = (3 * our0 + their0) // 4
            elif action == ALU_MID:
                wanted_price = (our0 + their0) // 2
            elif action == ALU_MID_FAR:
                wanted_price = (our0 + 3 * their0) // 4
            if mode == MLU_BUY:
                if wanted_price >= their0:
                    return their0 - PRICE_RESOLUTION
                else:
                    return wanted_price
            else:
                if wanted_price <= their0:
                    return their0 + PRICE_RESOLUTION
                else:
                    return wanted_price*/

    } else if (action >= rlexec_config['action_lu']['ALU_MID_NEAR'] && action <= rlexec_config['action_lu']['ALU_MID_FAR']) {
		if (action == rlexec_config['action_lu']['ALU_MID_NEAR']) {
			wanted_price = (3 * our0 + their0) / 4;
			console.log ('wanted_price = (3 * our0 + their0) / 4 = ' + wanted_price);
		} else if (action == rlexec_config['action_lu']['ALU_MID']) {
			wanted_price = (our0 + their0) / 2;
			console.log ('wanted_price = (our0 + their0) / 2 = ' + wanted_price);
		} else if (action == rlexec_config['action_lu']['ALU_MID_FAR']) {
			wanted_price = (our0 + 3 * their0) / 4;
			console.log ('wanted_price = (our0 + 3 * their0) / 4 = ' + wanted_price);
		}
        if (act['type'] == 'Buy') {
            if (wanted_price >= their0) {
                console.log('ALU_MID Buy: price = their0 - rez = ' + their0 - PRICE_RESOLUTION);
                return their0 - PRICE_RESOLUTION;
            } else {
                console.log('ALU_MID Buy: price = wanted_price = ' + wanted_price);
                return wanted_price;
            }
        } else {
            if (wanted_price <= their0) {
                console.log('ALU_MID Sell: price = their0 + rez = ' + (their0 + PRICE_RESOLUTION));
                return their0 + PRICE_RESOLUTION;
            } else {
                console.log('ALU_MID Sell: price = wanted_price = ' + wanted_price);
                return wanted_price;
            }
        }
    } else if (action == rlexec_config['action_lu']['ALU_FAR']) {
        if (act['type'] == 'Buy') {
            console.log('ALU_FAR Buy: price = their0 - rez = ' + their0 - PRICE_RESOLUTION);
            return their0 - PRICE_RESOLUTION;
        } else {
            console.log('ALU_FAR Sell: price = their0 + rez = ' + their0 + PRICE_RESOLUTION);
            return their0 + PRICE_RESOLUTION;
        }
	} else if (action >= rlexec_config['action_lu']['ALU_BR_0125'] && action <= rlexec_config['action_lu']['ALU_BR_075']) {
		if (action == rlexec_config['action_lu']['ALU_BR_0125']) {
			no_deeper_than = remaining_amount / 8;
			console.log ('ALU_BR_0125: no_deeper_than = vol / 8 = ' + no_deeper_than);
		} else {
			no_deeper_than = remaining_amount * (action - rlexec_config['action_lu']['ALU_BR_0125']) / 4;
			console.log ('ALU_BR: no_deeper_than = vol * ' + (action - rlexec_config['action_lu']['ALU_BR_0125']) + ' / 4 = ' + no_deeper_than);
		}
        no_deeper_than /= 100000000 * 0.5 * (parseFloat(our0) + parseFloat(their0));
        console.log('no_deeper_than /= 100000000 * ' + (0.5 * (parseFloat(our0) + parseFloat(their0))) + ' = ' + no_deeper_than + 'alt');
        price = parseFloat(u.get_depth_price (no_deeper_than, their_obkv));
		console.log ('raw price = ' + price + ' (their0 = ' + their0 + ')');
        if (act['type'] == 'Buy') {
			console.log ('price = ' + price + ' - ' + PRICE_RESOLUTION + ' = ' + (price - PRICE_RESOLUTION));
			return price - PRICE_RESOLUTION;
		} else {
			console.log ('price = ' + price + ' + ' + PRICE_RESOLUTION + ' = ' + (price + PRICE_RESOLUTION));
			return price + PRICE_RESOLUTION;
		}
	} else if (action == rlexec_config['action_lu']['ALU_MARKET']) {
        act['market_order'] = true;
        no_deeper_than = remaining_amount * 1.5; // to increase chance of being filled.
        if (act['type'] == 'Buy') {
            return parseFloat(u.get_depth_price (no_deeper_than, their_obkv)) + PRICE_RESOLUTION;
        } else {
            return parseFloat(u.get_depth_price (no_deeper_than, their_obkv)) - PRICE_RESOLUTION;
        }
    } else {
        logging.error("Crashing - invalid action " + action);
        process.exit(1);
        throw "invalid action " + action;
    }
}

module.exports = {

    init: function (config, _polo) {
        polo = _polo;
        c = config;
        init_volumes (rlexec_config);
        policies = init_policies (rlexec_config);
    },

//  act={"start":1528285827585,"timeout":60,"prev_balance":0,"current_balance":0,"total_amount":74.86000318514343,"type":"Buy","my_orders":{},"amount_changed":0,"trades":[],"triggerRunning":true,"done":false}

    calc_new_orders: function (mname, act, market, remaining_amount) {

        if (mname == 'USDT_BTC' ) {
            vol_frac = Math.floor (100000000 * rlexec_config.vol_rez * remaining_amount /* * u.midprice (market) */ / rlexec_config.full_volume)
            console.log('mname = ' + mname + ' market = ' + market + ' vol_frac = int (100000000 * ' + rlexec_config.vol_rez + ' * ' + remaining_amount  + /*' * ' + u.midprice (market)  +*/ ' / ' + rlexec_config.full_volume + ') = ' + vol_frac + "(" + (100000000 * rlexec_config.vol_rez * remaining_amount  /** u.midprice (market)*/ / rlexec_config.full_volume) + ")");
        } else {
            vol_frac = Math.floor (100000000 * rlexec_config.vol_rez * remaining_amount  * u.midprice (market) / rlexec_config.full_volume)
            console.log('mname = ' + mname + ' market = ' + market + ' vol_frac = int (100000000 * ' + rlexec_config.vol_rez + ' * ' + remaining_amount  + ' * ' + u.midprice (market)  + ' / ' + rlexec_config.full_volume + ') = ' + vol_frac + "(" + (100000000 * rlexec_config.vol_rez * remaining_amount  * u.midprice (market) / rlexec_config.full_volume) + ")");
        }
        if (vol_frac < 0 || vol_frac > rlexec_config.vol_rez - 1) {
            console.log('Crashing - vol_rez = ' + rlexec_config.vol_rez);
            process.exit(1);
            throw new RangeError('Crashing - vol_rez = ' + rlexec_config.vol_rez);
        }

//        time_frac = Math.floor (rlexec_config.time_rez * (1. - (Date.now() - act['start']) / act['timeout']))
        time_frac = Math.floor (rlexec_config.time_rez * ((Date.now() - act['start']) / (act['timeout'] * 1000.)))
        console.log('time_frac = int (' + rlexec_config.time_rez + ' * (' + Date.now() + ' - ' + act['start'] + ') / ' + act['timeout'] * 1000. + ') = ' + time_frac);
        if (time_frac > rlexec_config.time_rez - 1) {
            console.log('action = ALU_MARKET');
            action = rlexec_config['action_lu']['ALU_MARKET'];
            if (time_frac > rlexec_config.time_rez + 3) {
                console.log('Crashing - unable to execute market order');
                process.exit(1);
            }
        } else if (time_frac < 0) {
            console.log('Crashing - time_rez = ' + rlexec_config.time_rez);
            process.exit(1);
            throw new RangeError('Crashing - time_rez = ' + rlexec_config.time_rez);
        } 
        else {
            action = policies[mname][rlexec_config['types'][act['type']]][time_frac][vol_frac];
            console.log('action = ' + action);
            if (action < 0 || action > rlexec_config['noof_actions']) {
                console.log('Crashing - action = ' + action);
                process.exit(1);
                throw new RangeError('Crashing - action = ' + action);
            }
        }

        price = parseFloat(action_price(market, act, action, remaining_amount)).toFixed(8);

        ret = {};
        ret[price] = {      'mname':    mname,
                            'rate':     price,
                            'type':     act['type'],
                            'amount':   remaining_amount.toFixed(8), };
        console.log("Confabulator returning " + JSON.stringify (ret));
        return ret;
    }
/*    calc_new_orders: function (mname, act, market, remaining_amount) {
*/
        /*
        if (act['type'] != 'Buy') {
            console.log('Cannot confabulate sell orders.');
            return;
        }
        */
/*
        now = Date.now();

        // Trivial stupid ass thing
        if (now - act['start'] > act['timeout'] * 1000) {
            if (act['type'] == 'Buy') {
                return marketBuy(mname, remaining_amount, market);
            } else if (act['type'] == 'Sell') {
                return marketSell(mname, remaining_amount, market);
            } else {
                console.log("Unknown order type: " + act['type']);
            }
        }

//        dumpOB(market['ob_bids']);

        stupidReturnValue = {};
        
        if (act['type'] == 'Buy') {
            price = getSortedOB(market['ob_bids']).reverse()[0][0] + (c['PAPER_TRADE'] ? 0 : c['PRICE_RESOLUTION']);
            console.log("New order price: " + price + " (" + (act['start'] + act['timeout'] * 1000 - now) + "ms remaining)");

            stupidReturnValue[price] = {    'mname': mname,
                                            'rate': price,
                                            'type': 'Buy',
                                            'amount': remaining_amount, };
        } else if (act['type'] == 'Sell') {
            price = getSortedOB(market['ob_asks'])[0][0] - (c['PAPER_TRADE'] ? 0 : c['PRICE_RESOLUTION']);
            console.log("New order price: " + price + " (" + (act['start'] + act['timeout'] * 1000 - now) + "ms remaining)");

            stupidReturnValue[price] = {    'mname': mname,
                                            'rate': price,
                                            'type': 'Sell',
                                            'amount': remaining_amount, };
        } else {
            console.log("Unknown order type: " + act['type']);
        }

        return stupidReturnValue;
/*        return { price: {'mname': mname,
                         'rate': price,
                         'type': 'Buy',
                         'amount': remaining_amount
        }};*/
/*    },

};

function marketBuy(mname, remaining_amount, market) {

    console.log("\n*** MARKET BUY ***\n");
    price = 2 * getSortedOB(market['ob_bids']).reverse()[0][0];

    stupidReturnValue = {};
    stupidReturnValue[price] = {    'mname': mname,
                                    'rate': price,
                                    'type': 'Buy',
                                    'amount': remaining_amount, };
    return stupidReturnValue;
/*    return { price: {'mname': mname,  // How?! How can you think price is a literal?!
                     'rate': price,
                     'type': 'Buy',
                     'amount': remaining_amount,
    }};*/
/*
}

function marketSell(mname, remaining_amount, market) {

    console.log("\n*** MARKET SELL ***\n");
    price = 0.5 * getSortedOB(market['ob_asks'])[0][0];

    stupidReturnValue = {};
    stupidReturnValue[price] = {    'mname': mname,
                                    'rate': price,
                                    'type': 'Sell',
                                    'amount': remaining_amount, };
    return stupidReturnValue;
/*    return { price: {'mname': mname,  // How?! How can you think price is a literal?!
                     'rate': price,
                     'type': 'Buy',
                     'amount': remaining_amount,
    }};*/

}


/*    def action_price (self, action, e, mode):   # This is adapted from gym env, and should probably be put in a separate place.
                                                # Also, this is markedly different from the paper method of getting prices, which I don't understand.
        if action <= ALU_00625AV:
#            no_deeper_than = self.average_volume * 2. ** (-action)
            no_deeper_than = e.average_volume * 2. ** (-action)
            logging.debug ('no_deeper_than = ' + str(no_deeper_than) + 'altsat')
            v = 0
            volume = 0
            i = 0
            if mode == MLU_BUY:
                our_obkv = e.bids_ob.__reversed__()
                our_obd = e.bids_ob
            else:
                our_obkv = e.asks_ob.keys()
                our_obd = e.asks_ob
            for price in our_obkv:
                i = i + 1
                volume = our_obd[price]
                logging.debug('price = ' +str(price) + 'bsat => v + volume = ' + str(v) + 'altsat + ' + str(volume) + 'altsat')
                if v + volume > no_deeper_than:
                    if mode == MLU_BUY:
                        if price + PRICE_RESOLUTION >= e.asks_ob.keys()[0]: # Don't overstep into their ob too soon
                            return price
                        else:
                            return price + PRICE_RESOLUTION
                    else:
                        if price - PRICE_RESOLUTION <= e.bids_ob.keys()[-1]:
                            return price
                        else:
                            return price - PRICE_RESOLUTION
                else:
                    v = v + volume
            logging.error('length of ob: ' + str(len(our_obd.keys())) + ' after ' + str(i) + ' iterations')
#            assert False, 'v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action)
            logging.error('OB depleted: accum. v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action))
            logging.error('Our ob dump: ' + str(our_obd))
            assert False, 'market='+self.market+'length of ob: ' + str(len(our_obd.keys())) + ' after ' + str(i) + ' iterations'+'OB depleted: accum. v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action)+'Our ob dump: ' + str(our_obd)
        if mode == MLU_BUY:
            our0 = e.bids_ob.keys()[-1]
            their0 = e.asks_ob.keys()[0]
        else:
            our0 = e.asks_ob.keys()[0]
            their0 = e.bids_ob.keys()[-1]
        logging.debug('our0 = ' + str(our0) + 'bsat their0 = ' + str(their0) + 'bsat') */
/*        if action == ALU_NEAR:
            if mode == MLU_BUY:
                if our0 + PRICE_RESOLUTION >= their0:
                    return our0
                else:
                    return our0 + PRICE_RESOLUTION
            else:
                if our0 - PRICE_RESOLUTION <= their0:
                    return our0
                else:
                    return our0 - PRICE_RESOLUTION
        if action == ALU_MID:
            if mode == MLU_BUY:
                if (our0 + their0) // 2 >= their0:
                    return their0 - PRICE_RESOLUTION
                else:
                    return (our0 + their0) // 2
            else:
                if (our0 + their0) // 2 <= their0:
                    return their0 + PRICE_RESOLUTION
                else:
                    return (our0 + their0) // 2
        if action == ALU_FAR:
            if mode == MLU_BUY:
                return their0 - PRICE_RESOLUTION
            else:
                return their0 + PRICE_RESOLUTION*/
