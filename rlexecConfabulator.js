var fs = require ('fs');
var u = require('./utils');

var polo = null;
var c = null;
var volumes = null;
var policies = {};
var PRICE_RESOLUTION = 1;
var rlexec_config = { // TODO: This should be generated by rlexec itself
    noof_actions: 8,
    action_lu: {
        ALU_1AV:        0,
        ALU_05AV:       1,
        ALU_025AV:      2,
        ALU_0125AV:     3,
        ALU_00625AV:    4,
        ALU_NEAR:       5,
        ALU_MID:        6,
        ALU_FAR:        7,
        ALU_MARKET      8,
    },
    policy_dir: './rlexec_outputs/1536370926/',
    full_volume: 10000000, // 100mB
    full_period: 180000,  // 180s
    volumes_file: './volumes.json',
    policy_file: 'policy.json',
    volume_divizor = 30,    // TODO: This should not be linear (preferably recorded by rlexec per market)
    vol_rez = 8,
    time_rez = 8,
    types = {
        Buy:    0,
        Sell:   1,
    },
};

function init_volumes (rlc) {
	fs.readFile (rlc['volumes_file'], 'utf8', function (err, data) {
        if (err) {
            console.log(`Error reading volumes file ${fn}: ${err}`);
            return;
        }
        console.log(rlc['volumes_file'] + " dump: " + data);
		json = JSON.parse(data);
        for (market in Object.keys(data)) {
            volumes[market] = data[market] / rlc.volume_divizor;
        }
    });
}

function init_policies (rlc) {
    fs.readdir (rlc['policy_dir'], function (err, items) {
        if (err) {
            console.log('Error reading policy dir ' + rlc['policy_dir'] + ": " + err);
            return;
        }
        console.log("Got " + items.len + " market policies: " + JSON.stringify (items));
        for (market in items) {
            fn = rlc['policy_dir'] + market + '/' + rlc['policy_file'];
            fs.readFile (fn, function (err, data) {
                if (err) {
                    console.log('Error reading policy file ' + fn + ': ' + err);
                    return;
                }
                policies[market] = JSON.parse (data);
            });
        }
    });
}

function action_price(market, act, action, remaining_amount) {    // Should be an exact js rendition of rlexec function. Meh.

    if (act['type'] == 'Buy') {
//    return .5 * (getSortedOB(market['ob_bids']).reverse()[0][0] + getSortedOB(market['ob_asks'])[0][0]);
        our_obkv = getSortedOB(market['ob_bids']).reverse();
        their_obkv = getSortedOB(market['ob_asks']);
    } else {
        if (act['type'] != 'Sell') {
            throw "Unknown act type " + act['type'];
        }
        assert (act['type'] == 'Sell');
        our_obkv = getSortedOB(market['ob_asks']);
        their_obkv = getSortedOB(market['ob_bids']).reverse();
    }
    our0 = our_obkv[0][0];
    their0 = their_obkv[0][0];
    if (action <= ALI_00625AV) {
//        no_deeper_than = u.get_mid_price (market) * 2. ** (-action); // WAT?! This should be volume, not price.
        no_deeper_than = (volumes[act['mname']] / rlexec_config['volume_divizor'])  * 2. ** (-action);
        price = get_depth_price (no_deeper_than, our_obkv);
        if (act['type'] == 'Buy') {
            if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                return price;
            } else {
                return price + PRICE_RESOLUTION;
            }
        } else {
            if (price - PRICE_RESOLUTION <= their0) {
                return price;
            } else {
                return price - PRICE_RESOLUTION;
            }
        }

/*
        console.log ('no_deeper_than = ' + str(no_deeper_than) + 'altsat');
        v = 0;
        i = 0;
        for ((price, volume) in our_obkv) {
            i++;
            console.log('price = ' + str(price) + 'bsat => v + volume = ' + str(v) + 'altsat + ' + str(volume) + 'altsat');
            if (v + volume > no_deeper_than) {
                if (act['type'] == 'Buy') {
                    if (price + PRICE_RESOLUTION >= their0) { // Don't overstep into their ob too soon
                        return price;
                    } else {
                        return price + PRICE_RESOLUTION;
                    }
                } else {
                    if (price - PRICE_RESOLUTION <= their0) {
                        return price;
                    } else {
                        return price - PRICE_RESOLUTION;
                    }
                }
            } else {
                v += volume;
            }
        }
        throw "OB depleted";
*/
    } else if (action == ALU_NEAR) {
        if (act['type'] == 'Buy') {
            if (our0 + PRICE_RESOLUTION >= their0) {
                return our0;
            } else {
                return our0 + PRICE_RESOLUTION;
            }
        } else {
            if (our0 - PRICE_RESOLUTION <= their0) {
                return our0;
            } else {
                return our0 - PRICE_RESOLUTION;
            }
        }
    } else if (action == ALU_MID) {
        if (act['type'] == 'Buy') {
            if (Math.floor((our0 + their0) / 2) >= their0) {
                return their0 - PRICE_RESOLUTION;
            } else {
                return Math.floor((our0 + their0) / 2);
            }
        } else {
            if (Math.floor((our0 + their0) / 2) <= their0) {
                return their0 + PRICE_RESOLUTION;
            } else {
                return Math.floor((our0 + their0) / 2);
            }
        }
    } else if (action == ALU_FAR) {
        if (act['type'] == 'Buy') {
            return their0 - PRICE_RESOLUTION;
        } else {
            return their0 + PRICE_RESOLUTION;
        }
    } else if (action == ALU_MARKET) {
        no_deeper_than = remaining_amount * 1.5; // to increase chance of being filled.
        return get_depth_price (no_deeper_than, their_obkv);
    }
}


module.exports = {

    init: function (config, _polo) {
        polo = _polo;
        c = config;
        init_volumes (rlexec_config);
        policies = init_policies (rlexec_config);
    },

//  act={"start":1528285827585,"timeout":60,"prev_balance":0,"current_balance":0,"total_amount":74.86000318514343,"type":"Buy","my_orders":{},"amount_changed":0,"trades":[],"triggerRunning":true,"done":false}

    calc_new_orders: function (mname, act, market, remaining_amount) {

        vol_frac = int (vol_rez * remaining_amount * u.get_mid_price (market) / rlexec_config.full_volume)
        logging.error('vol_frac = int (' + str(vol_rez) + ' * ' + str(remaining_amount) + ' * ' + str(u.get_mid_price (market)) + ' / ' + str(rlexec_config.full_volume) + ') = ' + str(vol_frac));
        if (vol_frac < 0 || vol_frac > vol_rez - 1) {
            logging.error('Crashing - vol_rez = ' + str(vol_rez));
            throw new RangeError('Crashing - vol_rez = ' + str(vol_rez));
        }

        time_frac = int (time_rez * (1. - (Date.now() - act['start']) / act['timeout']))
        logging.error('time_frac = int (' + str(time_rez) + ' * (' + str(Date.now()) + ' - ' + str(act['start']) + ') / ' + str(act['timeout']) + ') = ' + str(time_frac));
        if (time_frac < 0) {
            logging.error('action = ALU_MARKET');
            action = ALU_MARKET;
        } else if (time_frac > time_rez - 1) {
            logging.error('Crashing - time_rez = ' + str(time_rez));
            throw new RangeError('Crashing - time_rez = ' + str(time_rez));
        } 
        else {
            action = policies[market][rlexec_config['types'][act['type']]][time_frac][vol_frac];
            logging.error('action = ' + str(action));
            if (action < 0 || action > rlexec_config['noof_actions']) {
                logging.error('Crashing - action = ' + str(action));
                throw new RangeError('Crashing - action = ' + str(action));
            }
        }

        price = action_price(market, act, action, remaining_amount);

        return  { price: {  'mname':    mname,
                            'rate':     price,
                            'type':     act['type'],
                            'amount':   remaining_amount, }, };
    }
    calc_new_orders: function (mname, act, market, remaining_amount) {

        /*
        if (act['type'] != 'Buy') {
            console.log('Cannot confabulate sell orders.');
            return;
        }
        */

        now = Date.now();

        // Trivial stupid ass thing
        if (now - act['start'] > act['timeout'] * 1000) {
            if (act['type'] == 'Buy') {
                return marketBuy(mname, remaining_amount, market);
            } else if (act['type'] == 'Sell') {
                return marketSell(mname, remaining_amount, market);
            } else {
                console.log("Unknown order type: " + act['type']);
            }
        }

//        dumpOB(market['ob_bids']);

        stupidReturnValue = {};
        
        if (act['type'] == 'Buy') {
            price = getSortedOB(market['ob_bids']).reverse()[0][0] + (c['PAPER_TRADE'] ? 0 : c['PRICE_RESOLUTION']);
            console.log("New order price: " + price + " (" + (act['start'] + act['timeout'] * 1000 - now) + "ms remaining)");

            stupidReturnValue[price] = {    'mname': mname,
                                            'rate': price,
                                            'type': 'Buy',
                                            'amount': remaining_amount, };
        } else if (act['type'] == 'Sell') {
            price = getSortedOB(market['ob_asks'])[0][0] - (c['PAPER_TRADE'] ? 0 : c['PRICE_RESOLUTION']);
            console.log("New order price: " + price + " (" + (act['start'] + act['timeout'] * 1000 - now) + "ms remaining)");

            stupidReturnValue[price] = {    'mname': mname,
                                            'rate': price,
                                            'type': 'Sell',
                                            'amount': remaining_amount, };
        } else {
            console.log("Unknown order type: " + act['type']);
        }

        return stupidReturnValue;
/*        return { price: {'mname': mname,
                         'rate': price,
                         'type': 'Buy',
                         'amount': remaining_amount
        }};*/
    },

};

function marketBuy(mname, remaining_amount, market) {

    console.log("\n*** MARKET BUY ***\n");
    price = 2 * getSortedOB(market['ob_bids']).reverse()[0][0];

    stupidReturnValue = {};
    stupidReturnValue[price] = {    'mname': mname,
                                    'rate': price,
                                    'type': 'Buy',
                                    'amount': remaining_amount, };
    return stupidReturnValue;
/*    return { price: {'mname': mname,  // How?! How can you think price is a literal?!
                     'rate': price,
                     'type': 'Buy',
                     'amount': remaining_amount,
    }};*/
}

function marketSell(mname, remaining_amount, market) {

    console.log("\n*** MARKET SELL ***\n");
    price = 0.5 * getSortedOB(market['ob_asks'])[0][0];

    stupidReturnValue = {};
    stupidReturnValue[price] = {    'mname': mname,
                                    'rate': price,
                                    'type': 'Sell',
                                    'amount': remaining_amount, };
    return stupidReturnValue;
/*    return { price: {'mname': mname,  // How?! How can you think price is a literal?!
                     'rate': price,
                     'type': 'Buy',
                     'amount': remaining_amount,
    }};*/
}


/*    def action_price (self, action, e, mode):   # This is adapted from gym env, and should probably be put in a separate place.
                                                # Also, this is markedly different from the paper method of getting prices, which I don't understand.
        if action <= ALU_00625AV:
#            no_deeper_than = self.average_volume * 2. ** (-action)
            no_deeper_than = e.average_volume * 2. ** (-action)
            logging.debug ('no_deeper_than = ' + str(no_deeper_than) + 'altsat')
            v = 0
            volume = 0
            i = 0
            if mode == MLU_BUY:
                our_obkv = e.bids_ob.__reversed__()
                our_obd = e.bids_ob
            else:
                our_obkv = e.asks_ob.keys()
                our_obd = e.asks_ob
            for price in our_obkv:
                i = i + 1
                volume = our_obd[price]
                logging.debug('price = ' +str(price) + 'bsat => v + volume = ' + str(v) + 'altsat + ' + str(volume) + 'altsat')
                if v + volume > no_deeper_than:
                    if mode == MLU_BUY:
                        if price + PRICE_RESOLUTION >= e.asks_ob.keys()[0]: # Don't overstep into their ob too soon
                            return price
                        else:
                            return price + PRICE_RESOLUTION
                    else:
                        if price - PRICE_RESOLUTION <= e.bids_ob.keys()[-1]:
                            return price
                        else:
                            return price - PRICE_RESOLUTION
                else:
                    v = v + volume
            logging.error('length of ob: ' + str(len(our_obd.keys())) + ' after ' + str(i) + ' iterations')
#            assert False, 'v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action)
            logging.error('OB depleted: accum. v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action))
            logging.error('Our ob dump: ' + str(our_obd))
            assert False, 'market='+self.market+'length of ob: ' + str(len(our_obd.keys())) + ' after ' + str(i) + ' iterations'+'OB depleted: accum. v = ' + str(v) + ', volume = ' + str(volume) + ', no_deeper_than = ' + str(no_deeper_than) + ', action = ' + str(action)+'Our ob dump: ' + str(our_obd)
        if mode == MLU_BUY:
            our0 = e.bids_ob.keys()[-1]
            their0 = e.asks_ob.keys()[0]
        else:
            our0 = e.asks_ob.keys()[0]
            their0 = e.bids_ob.keys()[-1]
        logging.debug('our0 = ' + str(our0) + 'bsat their0 = ' + str(their0) + 'bsat') */
/*        if action == ALU_NEAR:
            if mode == MLU_BUY:
                if our0 + PRICE_RESOLUTION >= their0:
                    return our0
                else:
                    return our0 + PRICE_RESOLUTION
            else:
                if our0 - PRICE_RESOLUTION <= their0:
                    return our0
                else:
                    return our0 - PRICE_RESOLUTION
        if action == ALU_MID:
            if mode == MLU_BUY:
                if (our0 + their0) // 2 >= their0:
                    return their0 - PRICE_RESOLUTION
                else:
                    return (our0 + their0) // 2
            else:
                if (our0 + their0) // 2 <= their0:
                    return their0 + PRICE_RESOLUTION
                else:
                    return (our0 + their0) // 2
        if action == ALU_FAR:
            if mode == MLU_BUY:
                return their0 - PRICE_RESOLUTION
            else:
                return their0 + PRICE_RESOLUTION*/
